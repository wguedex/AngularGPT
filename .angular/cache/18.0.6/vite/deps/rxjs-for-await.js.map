{
  "version": 3,
  "sources": ["../../../../../node_modules/rxjs-for-await/dist/esm/util/deferred.js", "../../../../../node_modules/rxjs-for-await/dist/esm/index.js"],
  "sourcesContent": ["export class Deferred {\n    constructor() {\n        this.resolve = null;\n        this.reject = null;\n        this.promise = new Promise((a, b) => {\n            this.resolve = a;\n            this.reject = b;\n        });\n    }\n}\n", "import { Deferred } from \"./util/deferred\";\nconst RESOLVED = Promise.resolve();\n/**\n * Will subscribe to the `source` observable provided,\n *\n * Allowing a `for await..of` loop to iterate over every\n * value that the source emits.\n *\n * **WARNING**: If the async loop is slower than the observable\n * producing values, the values will build up in a buffer\n * and you could experience an out of memory error.\n *\n * This is a lossless subscription method. No value\n * will be missed or duplicated.\n *\n * Example usage:\n *\n * ```ts\n * async function test() {\n *   const source$ = getSomeObservable();\n *\n *   for await(const value of eachValueFrom(source$)) {\n *     console.log(value);\n *   }\n * }\n * ```\n *\n * @param source the Observable source to await values from\n */\nexport async function* eachValueFrom(source) {\n    const deferreds = [];\n    const values = [];\n    let hasError = false;\n    let error = null;\n    let completed = false;\n    const subs = source.subscribe({\n        next: (value) => {\n            if (deferreds.length > 0) {\n                deferreds.shift().resolve({ value, done: false });\n            }\n            else {\n                values.push(value);\n            }\n        },\n        error: (err) => {\n            hasError = true;\n            error = err;\n            while (deferreds.length > 0) {\n                deferreds.shift().reject(err);\n            }\n        },\n        complete: () => {\n            completed = true;\n            while (deferreds.length > 0) {\n                deferreds.shift().resolve({ value: undefined, done: true });\n            }\n        },\n    });\n    try {\n        while (true) {\n            if (values.length > 0) {\n                yield values.shift();\n            }\n            else if (completed) {\n                return;\n            }\n            else if (hasError) {\n                throw error;\n            }\n            else {\n                const d = new Deferred();\n                deferreds.push(d);\n                const result = await d.promise;\n                if (result.done) {\n                    return;\n                }\n                else {\n                    yield result.value;\n                }\n            }\n        }\n    }\n    catch (err) {\n        throw err;\n    }\n    finally {\n        subs.unsubscribe();\n    }\n}\n/**\n * Will subscribe to the `source` observable provided\n * and build the emitted values up in a buffer. Allowing\n * `for await..of` loops to iterate and get the buffer\n * on each loop.\n *\n * This is a lossless subscription method. No value\n * will be missed or duplicated.\n *\n * Example usage:\n *\n * ```ts\n * async function test() {\n *   const source$ = getSomeObservable();\n *\n *   for await(const buffer of bufferedValuesFrom(source$)) {\n *     for (const value of buffer) {\n *       console.log(value);\n *     }\n *   }\n * }\n * ```\n *\n * @param source the Observable source to await values from\n */\nexport async function* bufferedValuesFrom(source) {\n    let deferred = null;\n    const buffer = [];\n    let hasError = false;\n    let error = null;\n    let completed = false;\n    const subs = source.subscribe({\n        next: (value) => {\n            if (deferred) {\n                deferred.resolve(RESOLVED.then(() => {\n                    const bufferCopy = buffer.slice();\n                    buffer.length = 0;\n                    return { value: bufferCopy, done: false };\n                }));\n                deferred = null;\n            }\n            buffer.push(value);\n        },\n        error: (err) => {\n            hasError = true;\n            error = err;\n            if (deferred) {\n                deferred.reject(err);\n                deferred = null;\n            }\n        },\n        complete: () => {\n            completed = true;\n            if (deferred) {\n                deferred.resolve({ value: undefined, done: true });\n                deferred = null;\n            }\n        },\n    });\n    try {\n        while (true) {\n            if (buffer.length > 0) {\n                const bufferCopy = buffer.slice();\n                buffer.length = 0;\n                yield bufferCopy;\n            }\n            else if (completed) {\n                return;\n            }\n            else if (hasError) {\n                throw error;\n            }\n            else {\n                deferred = new Deferred();\n                const result = await deferred.promise;\n                if (result.done) {\n                    return;\n                }\n                else {\n                    yield result.value;\n                }\n            }\n        }\n    }\n    catch (err) {\n        throw err;\n    }\n    finally {\n        subs.unsubscribe();\n    }\n}\n/**\n * Will subscribe to the provided `source` observable,\n * allowing `for await..of` loops to iterate and get the\n * most recent value that was emitted. Will not iterate out\n * the same emission twice.\n *\n * This is a lossy subscription method. Do not use if\n * every value is important.\n *\n * Example usage:\n *\n * ```ts\n * async function test() {\n *   const source$ = getSomeObservable();\n *\n *   for await(const value of latestValueFrom(source$)) {\n *     console.log(value);\n *   }\n * }\n * ```\n *\n * @param source the Observable source to await values from\n */\nexport async function* latestValueFrom(source) {\n    let deferred = undefined;\n    let latestValue;\n    let hasLatestValue = false;\n    let hasError = false;\n    let error = null;\n    let completed = false;\n    const subs = source.subscribe({\n        next: (value) => {\n            hasLatestValue = true;\n            latestValue = value;\n            if (deferred) {\n                deferred.resolve(RESOLVED.then(() => {\n                    hasLatestValue = false;\n                    return { value: latestValue, done: false };\n                }));\n            }\n        },\n        error: (err) => {\n            hasError = true;\n            error = err;\n            if (deferred) {\n                deferred.reject(err);\n            }\n        },\n        complete: () => {\n            completed = true;\n            if (deferred) {\n                hasLatestValue = false;\n                deferred.resolve({ value: undefined, done: true });\n            }\n        },\n    });\n    try {\n        while (true) {\n            if (hasLatestValue) {\n                await RESOLVED;\n                const value = latestValue;\n                hasLatestValue = false;\n                yield value;\n            }\n            else if (completed) {\n                return;\n            }\n            else if (hasError) {\n                throw error;\n            }\n            else {\n                deferred = new Deferred();\n                const result = await deferred.promise;\n                if (result.done) {\n                    return;\n                }\n                else {\n                    yield result.value;\n                }\n            }\n        }\n    }\n    catch (err) {\n        throw err;\n    }\n    finally {\n        subs.unsubscribe();\n    }\n}\n/**\n * Subscribes to the provided `source` observable and allows\n * `for await..of` loops to iterate over it, such that\n * all values are dropped until the iteration occurs, then\n * the very next value that arrives is provided to the\n * `for await` loop.\n *\n * This is a lossy subscription method. Do not use if\n * every value is important.\n *\n * Example usage:\n *\n * ```ts\n * async function test() {\n *   const source$ = getSomeObservable();\n *\n *   for await(const value of nextValueFrom(source$)) {\n *     console.log(value);\n *   }\n * }\n * ```\n *\n * @param source the Observable source to await values from\n */\nexport async function* nextValueFrom(source) {\n    let deferred = undefined;\n    let hasError = false;\n    let error = null;\n    let completed = false;\n    const subs = source.subscribe({\n        next: (value) => {\n            if (deferred) {\n                deferred.resolve({ value, done: false });\n            }\n        },\n        error: (err) => {\n            hasError = true;\n            error = err;\n            if (deferred) {\n                deferred.reject(err);\n            }\n        },\n        complete: () => {\n            completed = true;\n            if (deferred) {\n                deferred.resolve({ value: undefined, done: true });\n            }\n        },\n    });\n    try {\n        while (true) {\n            if (completed) {\n                return;\n            }\n            else if (hasError) {\n                throw error;\n            }\n            else {\n                deferred = new Deferred();\n                const result = await deferred.promise;\n                if (result.done) {\n                    return;\n                }\n                else {\n                    yield result.value;\n                }\n            }\n        }\n    }\n    catch (err) {\n        throw err;\n    }\n    finally {\n        subs.unsubscribe();\n    }\n}\n"],
  "mappings": "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",
  "names": []
}
